heapq is a min heap setup built in to python
heapq.heapify(heap) will turn a list (heap) into a heap item
https://docs.python.org/2/library/heapq.html

collections is a more complex list of datatypes available in python
https://docs.python.org/2/library/collections.html
deque is perfect for popping items from both directions (stack and/or queue)
counter is useful for building hash tables to count items. You can use the most_common function

hash() will return a unique hash number for any item. You can use this to find anagrams by summing the hash of letters and comparing them. abc == cab
hash('a')+hash('b')+hash('c') == hash('c')+hash('a')+hash('b')
https://docs.python.org/3.8/library/functions.html#hash


#uses heapq, which is a min heap setup
#uses negative freq because it wants the highest frequency to be the first 
#available in the queue but then uses negative again to make it a 
#positive number again


import collections 
import heapq
class Solution:
    def frequencySort(self, s: str) -> str:
        counterMap = collections.Counter(s)
        res = ''
        hq = []
        for char, freq in counterMap.items():
            heapq.heappush(hq, (-freq, char))

        while hq:
            freq, char = heapq.heappop(hq)
            res += -freq*char
            
        return res

import collections 
class Solution:
    def frequencySort(self, s: str) -> str:
        cnt = Counter()
        for letter in s:
            cnt[letter] += 1
        data =  cnt.most_common() #produces tuple with (count, item)
        output = ''
        for i in range(len(data)):
            if data[i][1] == 1:
                output += data[i][0]
            else:
                for j in range(data[i][1]):
                    output += data[i][0]
        return output


import collections
import heapq

class Solution:
    def frequencySort(self, s: str) -> str:
        letterCountDict = {}
        
        for letter in s:
            if letter in letterCountDict:
                letterCountDict[letter]+=1
            else:
                letterCountDict[letter]=1
            
        heap = []
        result = []
        
        for key,value in letterCountDict.items():
            heap.append((-value,key))
        
        heapq.heapify(heap)
            
        
        while(len(heap) != 0):
            value, letter = heapq.heappop(heap)
            value*=-1
            for i in range(value):
                result.append(letter)
        
        return ''.join(result)

https://stackoverflow.com/questions/4383571/importing-files-from-different-folder
import sys
sys.path.append('../')

Sorting a list and returning the indexes of the sorted values is often useful
sorted_A = sorted(range(len(A)), key=lambda k: A[k])
Array > Medium Width Ramp
Sorting a list of lists by one of the indexes:
l.sort(key=lambda x: x[1])

collections.Counter is useful for counting occurrences in lists
itertools product is useful when you need permutations with repetition allowed
Morse Code>Cisco_Morse_Code_Challenge
import collections
    cnt = collections.Counter()
    for word in morse_words:
        cnt[word] += 1
    print(cnt.most_common(10))
permutations_list = [p for p in itertools.product(x, repeat=13)]

Initializing a two dimensional list:
x = [[foo for i in range(10)] for j in range(10)]

remove multiple items from a list in one line:
list = [e for e in original_list if e not in [1,2,3]]

find out if the sum of three dice rolls is prime:

def P(event, space):
    """The probability of an event, given a sample space of equiprobable outcomes.
    event can be either a set of outcomes, or a predicate (true for outcomes in the event)."""
    if is_predicate(event):
        event = such_that(event, space)
    return Fraction(len(event & space), len(space))

is_predicate = callable

def such_that(predicate, collection):
    "The subset of elements in the collection for which the predicate is true."
    return {e for e in collection if predicate(e)}

D3 = {(d1, d2, d3) for d1 in D for d2 in D for d3 in D}

def prime_sum(outcome): return is_prime(sum(outcome))

def is_prime(n): return n > 1 and not any(n % i == 0 for i in range(2, n))

P(prime_sum, D3)


Make a list of all the cards in a deck
def cross(A, B):
    "The set of ways of concatenating one item from collection A with one from B."
    return {a + b
            for a in A for b in B}

suits = 'SHDC'
ranks = 'A23456789TJQK'
deck  = cross(ranks, suits)