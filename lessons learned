heapq is a min heap setup built in to python
heapq.heapify(heap) will turn a list (heap) into a heap item
https://docs.python.org/2/library/heapq.html
See problem: Minimum cost to connect sticks

collections is a more complex list of datatypes available in python
https://docs.python.org/2/library/collections.html
deque is perfect for popping items from both directions (stack and/or queue)
counter is useful for building hash tables to count items. You can use the most_common function

hash() will return a unique hash number for any item. You can use this to find anagrams by summing the hash of letters and comparing them. abc == cab
hash('a')+hash('b')+hash('c') == hash('c')+hash('a')+hash('b')
https://docs.python.org/3.8/library/functions.html#hash


#uses heapq, which is a min heap setup
#uses negative freq because it wants the highest frequency to be the first 
#available in the queue but then uses negative again to make it a 
#positive number again


import collections 
import heapq
class Solution:
    def frequencySort(self, s: str) -> str:
        counterMap = collections.Counter(s)
        res = ''
        hq = []
        for char, freq in counterMap.items():
            heapq.heappush(hq, (-freq, char))

        while hq:
            freq, char = heapq.heappop(hq)
            res += -freq*char
            
        return res

import collections 
class Solution:
    def frequencySort(self, s: str) -> str:
        cnt = Counter()
        for letter in s:
            cnt[letter] += 1
        data =  cnt.most_common() #produces tuple with (count, item)
        output = ''
        for i in range(len(data)):
            if data[i][1] == 1:
                output += data[i][0]
            else:
                for j in range(data[i][1]):
                    output += data[i][0]
        return output


import collections
import heapq

class Solution:
    def frequencySort(self, s: str) -> str:
        letterCountDict = {}
        
        for letter in s:
            if letter in letterCountDict:
                letterCountDict[letter]+=1
            else:
                letterCountDict[letter]=1
            
        heap = []
        result = []
        
        for key,value in letterCountDict.items():
            heap.append((-value,key))
        
        heapq.heapify(heap)
            
        
        while(len(heap) != 0):
            value, letter = heapq.heappop(heap)
            value*=-1
            for i in range(value):
                result.append(letter)
        
        return ''.join(result)

https://stackoverflow.com/questions/4383571/importing-files-from-different-folder
import sys
sys.path.append('../')

Sorting a list and returning the indexes of the sorted values is often useful
sorted_A = sorted(range(len(A)), key=lambda k: A[k])
Array > Medium Width Ramp
Sorting a list of lists by one of the indexes:
l.sort(key=lambda x: x[1])

collections.Counter is useful for counting occurrences in lists
itertools product is useful when you need permutations with repetition allowed
Morse Code>Cisco_Morse_Code_Challenge
import collections
    cnt = collections.Counter()
    for word in morse_words:
        cnt[word] += 1
    print(cnt.most_common(10))
permutations_list = [p for p in itertools.product(x, repeat=13)]

Initializing a two dimensional list:
x = [[foo for i in range(10)] for j in range(10)]

remove multiple items from a list in one line:
list = [e for e in original_list if e not in [1,2,3]]

find out if the sum of three dice rolls is prime:

def P(event, space):
    """The probability of an event, given a sample space of equiprobable outcomes.
    event can be either a set of outcomes, or a predicate (true for outcomes in the event)."""
    if is_predicate(event):
        event = such_that(event, space)
    return Fraction(len(event & space), len(space))

is_predicate = callable

def such_that(predicate, collection):
    "The subset of elements in the collection for which the predicate is true."
    return {e for e in collection if predicate(e)}

D3 = {(d1, d2, d3) for d1 in D for d2 in D for d3 in D}

def prime_sum(outcome): return is_prime(sum(outcome))

def is_prime(n): return n > 1 and not any(n % i == 0 for i in range(2, n))

P(prime_sum, D3)


Make a list of all the cards in a deck
def cross(A, B):
    "The set of ways of concatenating one item from collection A with one from B."
    return {a + b
            for a in A for b in B}

suits = 'SHDC'
ranks = 'A23456789TJQK'
deck  = cross(ranks, suits)

combining a list of numbers to a string:
ans = ''.join(map(str, LIST))

l1 = [1,"hi",None]
#creating a shallow copy of a list
l2 = l1 #This changes the memory location of l2
#creating a deep copy of a list
l2 = l1[:] #This does not change the memory location of l2

zip two lists into one:
ans = []
for j, k in zip(list1, list2):
    ans.append(j)
    ans.append(k)

find all indexes of a char in a string:
def find1(str, ch):
  # 0.100 seconds for 1MB str
  npbuf = np.frombuffer(str, dtype=np.uint8) # Reinterpret str as a char buffer
  return np.where(npbuf == ord(ch))          # Find indices with numpy

def find2(str, ch):
  # 0.920 seconds for 1MB str
  return [i for i, c in enumerate(str) if c == ch] # Find indices with python

get kth column of a matrix:
res = [sub[K] for sub in test_list]

finding columns of a list of lists:
return sum([list(col) != sorted(col) for col in zip(*A)])
The * indicates that A is an iterable
cols = list(zip(*mat)) #mat is a 2D matrix

#Unzips the list and compares each letter to all other letters in all other words until one doesn't match and then breaks
#group will look like ['f','f','f'] for the first example
#res will look like ['f','l'] for the first example
class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        res = []
        for group in zip(*strs):
            if len(set(group)) > 1: break
            res.append(group[0])
        return "".join(res)

Check if counter has only positive values:
if Counter == Counter()

find index of max in list
maxxi = max((v, i) for i, v in enumerate(a))[1]

https://leetcode.com/discuss/interview-question/344650/Amazon-Online-Assessment-Questions

Piperclip has copy and paste functions in python to use the computer’s clipboard

Using the command line for python3:
The shebang line tells your computer that you want to run the script using python 3
On windows, you can bring up the Run dialog by pressing Win+R
A batch file can save you a lot of typing by running multiple commands
The batch files you’ll make will look like this:

@py C:\Users\Al\MyPythonScripts\hello.py %*
@pause

You’ll need to add the MyPythonScripts folder to the PATH environment variable first
Command-line arguments can be read in the sys.argv list

Regular expressions objects:
Import re
Because regular expressions have a lot of backslashes in them, use raw strings formatted like r''
Find all phone numbers in a message:
import re
phoneNumRegex = re.compile(r'\d\d\d-\d\d\d-\d\d\d\d')
#Create a match object
#Search finds the first phone number in the message
mo = phoneNumRegex.search('Call me at 555-555-5555 tomorrow')
print(mo.group())
#Findall finds all of the numbers
mo = phoneNumRegex.findall('Call me at 555-555-5555 tomorrow')
print(mo.group())
Regular expressions are mini-language for speyfying text patterns. Writing code to do pattern matching without regular expressions is a huge pain.
Regex strings often use \ backslashes like \d so they are often raw strings
Import re module first
Call the re.compile() function to create a regex object
Call the regex object search() method to create a match object
Call the match object's group() method to get the matched string
\d is the regex for a numeric digit character
Groups are created in regex strings with parentheses
The first set of parentheses is group1, the second is 2 and so on.
Calling group() or group(0) returns the full matching string, group(1) returns group 1's matching string, and so on
Use \( and \) to match literal parentheses in the regex string
The pipe | character can match one of many possible groups
The ? says the group matches 0 or 1 times
the * says the group matches 0+ times
the + says the group matches 1+ times
The curly braces can match a specific number of times
The curly braces with two numbers matches a minimum and a maximum number of times
Leaving out the first or second number in the curly braces says there is no minimum or maximum respectively
Greedy matching - match the longest string possible, nongreedy matching - match the shortest string posssible
Putting a question mark after the curly braces makes it do a nongreedy match
#! python3
# phoneAndEmail.py - Finds phone numbers and email addresses on the clipboard.
import pyperclip, re
#Create a Regex for Phone Numbers
phoneRegex = re.compile(r'''(
    (\d{3}|\(\d{3}\))?                # area code
    (\s|-|\.)?                        # separator
    (\d{3})                           # first 3 digits
    (\s|-|\.)                         # separator
    (\d{4})                           # last 4 digits
    (\s*(ext|x|ext.)\s*(\d{2,5}))?    # extension
    )''', re.VERBOSE)
#Create a Regex for Email Addresses
emailRegex = re.compile(r'''(
    [a-zA-Z0-9._%+-]+      # username
    @                      # @ symbol
    [a-zA-Z0-9.-]+         # domain name
    (\.[a-zA-Z]{2,4})      # dot-something
    )''', re.VERBOSE)
# Find matches in clipboard text.
text = str(pyperclip.paste())
matches = []
for groups in phoneRegex.findall(text):
    phoneNum = '-'.join([groups[1], groups[3], groups[5]])
    if groups[8] != '':
        phoneNum += ' x' + groups[8]
    matches.append(phoneNum)
for groups in emailRegex.findall(text):
    matches.append(groups[0])
#Copy results to the clipboard.
if len(matches) > 0:
    pyperclip.copy('\n'.join(matches))
    print('Copied to clipboard:')
    print('\n'.join(matches))
else:
    print('No phone numbers or email addresses found.')

Use logging instead of print statements to debug
os.walk() searches through directory
Raise and assert for errors
use zipfile for zip files
Safe deletes with send2trash
moving and renaming files: shutil.move('C:\\bacon.txt', 'C:\\eggs\\new_bacon.txt')
webbrowser - opens a browser to a specific page
requests downloads files and web pages from the internet http://requests.readthedocs.org/
Beautiful Soup - Parses HTML, the format that web pages are written in
Selenium - Launches and controls a web browser/ Selenium is able to fill in forms and simulate mouse clicks in this browser
Pragmatic unicode - bit.ly/unipain

html tutorials: http://htmldog.com/guides/html/beginner/ http://www.codecademy.com/tracks/web/ https://developer.mozilla.org/en-US/learn/html/

import requests, bs4
def getAmazonPrice(productUrl):
    res = requests.get(productUrl)
    res.raise_for_status()

    soup = bs4.BeautifulSoup(res.text, 'html.parser')
    #Go to web page, right click on price, inspect element, copy path name
    elems = soup.select('html.a-ws.a-js.a-audio.a-video.a-canvas.a-svg.a-drag-drop.a-geolocation.a-history.a-webworker.a-autofocus.a-input-placeholder.a-textarea-placeholder.a-local-storage.a-gradients.a-transform3d.-scrolling.a-text-shadow.a-text-stroke.a-box-shadow.a-border-radius.a-border-image.a-opacity.a-transform.a-transition.a-ember body.a-m-us.a-aui_72554-c.a-aui_control_group_273125-t1.a-aui_dropdown_274033-t1.a-aui_link_rel_noreferrer_noopener_274172-c.a-aui_mm_desktop_exp_291916-c.a-aui_mm_desktop_launch_291918-c.a-aui_mm_desktop_targeted_exp_291928-t1.a-aui_mm_desktop_targeted_launch_291922-t1.a-aui_pci_risk_banner_210084-c.a-aui_perf_130093-c.a-aui_preload_261698-c.a-aui_tnr_v2_180836-c div#a-page div#dp.musical_instruments.en_US div#dp-container.a-container div#ppd div#rightCol.rightCol.rightCol-bbcxoverride div#desktop_buybox.celwidget div#buybox div#qualifiedBuybox.celwidget div.a-section form#addToCart.a-content div.a-box-group div.a-box.a-last div.a-box-inner div.a-section.a-spacing-none.a-padding-none div#priceInsideBuyBox_feature_div.celwidget div.a-section span#price_inside_buybox.a-size-medium.a-color-price')
    return elems[0].text.strip()

ideas for web scraping:
get weather data from www.weather.gov
go to xkcd.com and download all the funny images